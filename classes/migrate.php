<?php
/**
 * Part of the Fuel framework.
 *
 * @package    Fuel
 * @version    1.0
 * @author     Fuel Development Team
 * @license    MIT License
 * @copyright  2010 - 2011 Fuel Development Team
 * @link       http://fuelphp.com
 */

namespace Fuel\Core;

/**
 * Migrate Class
 *
 * @package		Fuel
 * @category	Migrations
 * @author		Phil Sturgeon
 * @link		http://fuelphp.com/docs/classes/migrate.html
 */
class Migrate
{
	public static $version = array();

	protected static $prefix = '\\Fuel\\Migrations\\';

	protected static $table = 'migration';

	protected static $table_definition = array(
		'name' => array('type' => 'varchar', 'constraint' => 50),
		'type' => array('type' => 'varchar', 'constraint' => 25),
		'version' => array('type' => 'int', 'constraint' => 11, 'null' => false, 'default' => 0),
	);

	public static function _init()
	{
		logger(Fuel::L_DEBUG, 'Migrate class initialized');

		\Config::load('migrations', true);

		static::$table = \Config::get('migrations.table', static::$table);

		// installs or upgrades table
		static::table_check();

		//get all versions from db
		$migrations = \DB::select()
			->from(static::$table)
			->execute()
			->as_array();

		foreach ($migrations as $migration)
		{
			static::$version[$migration['type']][$migration['name']] = (int) $migration['version'];
		}
	}

	/**
	 * Set's the schema to the latest migration
	 *
	 * @access	public
	 * @return	mixed	true if already latest, false if failed, int if upgraded
	 */
	public static function latest($name = 'default', $type = 'app')
	{
		if ( ! $migrations = static::find_migrations($name, $type))
		{
			throw new FuelException('no_migrations_found');
			return false;
		}

		$last_migration = basename(end($migrations));

		// Calculate the last migration step from existing migration
		// filenames and procceed to the standard version migration
		$last_version = intval(substr($last_migration, 0, 3));

		return static::version($last_version, $name, $type);
	}

	// --------------------------------------------------------------------

	/**
	 * Set's the schema to the migration version set in config
	 *
	 * @access	public
	 * @return	mixed	true if already current, false if failed, int if upgraded
	 */
	public static function current($name = 'default', $type = 'app')
	{
		return static::version(\Config::get('migrations.version.'.$type.'.'.$name), $name, $type);
	}

	// --------------------------------------------------------------------

	/**
	 * Migrate to a schema version
	 *
	 * Calls each migration step required to get to the schema version of
	 * choice
	 *
	 * @access	public
	 * @param $version integer	Target schema version
	 * @return	mixed	true if already latest, false if failed, int if upgraded
	 */
	public static function version($version, $name = 'default', $type = 'app')
	{
		// if version isn't set
		if ( ! isset(static::$version[$type][$name]))
		{
			// insert into db
			\DB::insert(static::$table)
			->set(array(
				'name' => $name,
				'type' => $type,
				'version' => 0,
			))
			->execute();

			// set verstion to 0
			static::$version[$type][$name] = 0;
		}

		// return false if current version equals requested version
		if (static::$version[$type][$name] === $version)
		{
			return false;
		}

		// set vars for loop
		$start = static::$version[$type][$name];
		$stop = $version;

		// modify loop vars and add step
		if ($version > static::$version[$type][$name])
		{
			// Moving Up
			++$start;
			++$stop;
			$step = 1;
		}

		else
		{
			// Moving Down
			$step = -1;
		}

		$method = $step === 1 ? 'up' : 'down';
		$migrations = array();

		// We now prepare to actually DO the migrations
		// But first let's make sure that everything is the way it should be
		for ($i = $start; $i != $stop; $i += $step)
		{
			if ($type)
			{
				$get_method = '_find_'.$type;
				$f = static::$get_method($name, $i);
			}
			else
			{
				$f = static::_get_default($i);
			}

			// Only one migration per step is permitted
			if (count($f) > 1)
			{
				throw new FuelException('multiple_migrations_version');
				return false;
			}

			// Migration step not found
			if (count($f) == 0)
			{
				// If trying to migrate up to a version greater than the last
				// existing one, migrate to the last one.
				if ($step == 1) break;

				// If trying to migrate down but we're missing a step,
				// something must definitely be wrong.
				throw new FuelException('migration_not_found');
				return false;
			}

			$file = basename($f[0]);
			$file_name = basename($f[0], '.php');

			// Filename validations
			if (preg_match('/^\d{3}_(\w+)$/', $file_name, $match))
			{
				$match[1] = strtolower($match[1]);

				// Cannot repeat a migration at different steps
				if (in_array($match[1], $migrations))
				{
					throw new FuelException('multiple_migrations_name');
					return false;
				}

				include $f[0];
				$class = static::$prefix . ucfirst($match[1]);

				if ( ! class_exists($class, false))
				{
					throw new FuelException('migration_class_doesnt_exist');
					return false;
				}

				if ( ! is_callable(array($class, 'up')) || !is_callable(array($class, 'down')))
				{
					throw new FuelException('wrong_migration_interface');
					return false;
				}

				$migrations[] = $match[1];
			}
			else
			{
				throw new FuelException('invalid_migration_filename');
				return false;
			}
		}

		$version = $i + ($step == 1 ? -1 : 0);

		// If there is nothing to do, bitch and quit
		if ($migrations === array())
		{
			return false;
		}

		// Loop through the migrations
		foreach ($migrations as $migration)
		{
			logger(Fuel::L_INFO, 'Migrating to: '.static::$version + $step);

			$class = static::$prefix . ucfirst($migration);
			call_user_func(array(new $class, $method));

			static::$version[$type][$name] += $step;

			static::_update_schema_version(static::$version[$type][$name] - $step, static::$version[$type][$name], $name, $type);
		}

		logger(Fuel::L_INFO, 'Migrated to ' . static::$version.' successfully.');

		return static::$version[$type][$name];
	}

	// --------------------------------------------------------------------

	/**
	 * Set's the schema to the latest migration
	 *
	 * @access	public
	 * @return	mixed	true if already latest, false if failed, int if upgraded
	 */

	protected static function find_migrations($name, $type)
	{
		// Load all *_*.php files in the migrations path
		$method = '_find_'.$type;
		$files = static::$method($name);

		$file_count = count($files);

		for ($i = 0; $i < $file_count; $i++)
		{
			// Mark wrongly formatted files as false for later filtering
			$name = basename($files[$i], '.php');
			if ( ! preg_match('/^\d{3}_(\w+)$/', $name))
			{
				$files[$i] = false;
			}
		}

		return $files;
	}

	// --------------------------------------------------------------------

	/**
	 * Stores the current schema version
	 *
	 * @access	private
	 * @param $schema_version integer	Schema version reached
	 * @return	void					Outputs a report of the migration
	 */
	private static function _update_schema_version($old_version, $version, $name, $type = '')
	{
		\DB::update(static::$table)
			->set(array(
				'version' => (int) $version
			))
			->where('version', (int) $old_version)
			->where('name', $name)
			->where('type', $type)
			->execute();
	}

	/**
	 * Finds migrations for the fuel/app
	 *
	 * @param string
	 * @param string
	 */
	private static function _find_app($name = null, $file = null)
	{
		if ($file)
		{
			if ( ! isset($name))
			{
				throw new FuelException('Name must be set to find a specific file');
				return false;
			}

			return glob(APPPATH . \Config::get('migrations.folder') . str_pad($file, 3, '0', STR_PAD_LEFT) . "_*.php");;
		}

		return glob(APPPATH . \Config::get('migrations.folder') . '*_*.php');
	}

	/**
	 * Finds migrations for modules
	 *
	 * @param string
	 * @param string
	 */
	private static function _find_module($name = null, $file = null)
	{
		if ($file)
		{
			if ( ! isset($name))
			{
				throw new FuelException('Name must be set to find a specific file');
				return false;
			}

			foreach (\Config::get('module_paths') as $m)
			{
				return glob($m .$name.'/'. \Config::get('migrations.folder') . str_pad($file, 3, '0', STR_PAD_LEFT) . "_*.php");
			}
		}

		if ($name)
		{
			// find a module
			foreach (\Config::get('module_paths') as $m)
			{
				$files = glob($m .$name.'/'. \Config::get('migrations.folder') . '*_*.php');
			}
		}
		else
		{
			// find all modules
			foreach (\Config::get('module_paths') as $m)
			{
				$files = glob($m .'*/'. \Config::get('migrations.folder') . '*_*.php');
			}
		}

		return $files;
	}

	/**
	 * Finds migrations for packages
	 *
	 * @param string
	 * @param string
	 */
	private static function _find_package($name = null, $file = null)
	{
		if ($file)
		{
			if ( ! isset($name))
			{
				throw new FuelException('Name must be set to find a specific file');
				return false;
			}

			return glob(PKGPATH .$name.'/'. \Config::get('migrations.folder') . str_pad($file, 3, '0', STR_PAD_LEFT) . "_*.php");;
		}

		if ($name)
		{
			// find a package
			$files = glob(PKGPATH .$name.'/'. \Config::get('migrations.folder') . '*_*.php');
		}
		else
		{
			// find all modules
			$files = glob(PKGPATH .'*/'. \Config::get('migrations.folder') . '*_*.php');
		}

		return $files;
	}

	/**
	 * Installs or upgrades migration table
	 *
	 * @deprecated	Remove upgrade check in 1.2
	 */
	private static function table_check()
	{
		// if table does not exist
		if ( ! \DBUtil::table_exists(static::$table))
		{
			// create table
			\DBUtil::create_table(static::$table, static::$table_definition);
		}
		elseif ( ! \DBUtil::field_exists(static::$table, array('name', 'type')))
		{
			$current = \DB::select('current')->from(static::$table)->limit(1)->execute()->get('current');

			\DBUtil::drop_table(static::$table);
			\DBUtil::create_table(static::$table, static::$table_definition);

			\DB::insert(static::$table)->set(array(
				'name' => 'default',
				'type' => 'app',
				'version' => (int) $current
			))->execute();
		}
	}
}

